/* Utility program to recover ZIP archives generated by mvme that got corrupted
 * due to a crash.
 *
 * Based on BruteZip by Jason A. Donenfeld, https://git.zx2c4.com/BruteZip/about/
 *
 * Modifications by flueke <f.lueke@mesytec.com> (2018):
 * - Make the program quit after it found and deflated a single file. That's
 *   the case for broken mvme archives.
 * - Ignore header.compressedsize as it's set to uint32_t max which is not correct.
 *   Instead stop deflating the single file once eof is reached in the input file.
 * - Make sure header.compression == 8 as otherwise the code doesn't do any
 *   deflating. (A value != 8 makes the code create a subdirectory, so I guess
 *   it's for handling a directory structure inside the archive. mvme doesn't
 *   use this feature at the moment.)
 * - Add usage and fix crash when the input file cannot be opened.
 */

#include <errno.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <sys/stat.h>
#include <zlib.h>

typedef struct {
	uint32_t sig __attribute__ ((packed));
	uint16_t version __attribute__ ((packed));
	uint16_t gen __attribute__ ((packed));
	uint16_t compression __attribute__ ((packed));
	uint16_t modtime __attribute__ ((packed));
	uint16_t moddate __attribute__ ((packed));
	uint32_t crc32 __attribute__ ((packed));
	uint32_t compressedsize __attribute__ ((packed));
	uint32_t uncompressedsize __attribute__ ((packed));
	uint16_t filenamelength __attribute__ ((packed));
	uint16_t extrafieldlength __attribute__ ((packed));
} lfh;

typedef struct {
	uint32_t crc32 __attribute__ ((packed));
	uint32_t compressedsize __attribute__ ((packed));
	uint32_t uncompressedsize __attribute__ ((packed));
} dd;

int main(int argc, char *argv[])
{
	union {
		long int l;
		char c[sizeof(long int)];
	} u;
	u.l = 1;

	if (u.c[sizeof(long int) - 1] == 1) {
		printf("This program only runs on little endian archs, because I'm lazy. Sorry.\n");
		return 2;
	}

	if (argc != 2)
    {
        printf("Usage: %s <input_zip_file>\n", argv[0]);
		return 1;
    }

	FILE *fh = fopen(argv[1], "rb");

    if (!fh)
    {
        printf("Error opening input file '%s' for reading: %s.\n",
                argv[1], strerror(errno));
        return 1;
    }

	FILE *ofh;
	lfh header;
	dd des;
	uint32_t sig;
	int first = 0;
	unsigned long long lastloc, startloc, i, len;
	char filename[UINT16_MAX];
	char buffer[0x10000];
	char zbuffer[0x10000];
	int ret;
	z_stream strm;
    size_t of_size = 0; // output file size

	while (!feof(fh))
    {
		if (!first)
        {
			fread(&sig, sizeof(sig), 1, fh);
			if (sig == 0x04034b50) {
                printf("Found local file header signature.\n");
				fseek(fh, -sizeof(sig), SEEK_CUR);
			} else {
				printf("Brute-force seeking til next sig.\n");
				fseek(fh, lastloc + sizeof(header.sig), SEEK_SET);

				while (!feof(fh)) {
					fread(&sig, sizeof(sig), 1, fh);
					if (sig == 0x04034b50) {
						fseek(fh, -sizeof(sig), SEEK_CUR);
						break;
					} else
						fseek(fh, -(sizeof(sig) - 1), SEEK_CUR);
				}
			}
		}

		lastloc = ftell(fh);
		fread(&header, sizeof(header), 1, fh);
		fread(filename, sizeof(char), header.filenamelength, fh);
		filename[header.filenamelength] = 0;

        printf("Found filename %s\n", filename);

		fseek(fh, header.extrafieldlength, SEEK_CUR);
		startloc = ftell(fh);

        // Note (flueke): the file I'm trying to recover does not have an optional
        // data descriptor. As this code reads 4 byte at a time it takes
        // quite a while to finish so I'm commenting it out.
#if 0
		if (header.gen & (1 << 3))
        {
            printf("bit 3 of general purpose flags is set -> crc and file sizes are not known\n");

            printf("Searching for optional data descriptor signature\n");
            int optsig_found = 0;
			while (!feof(fh))
            {
				fread(&sig, sizeof(sig), 1, fh);

				if (sig == 0x08074b50)
                {
                    optsig_found = 1;
					break;
                }
				else
                {
					fseek(fh, -(sizeof(sig) - 1), SEEK_CUR);
                }
			}

            if (optsig_found)
                printf("Found optional data descriptor signature\n");
            else
                printf("Did not find optional data descriptor signature\n");

			fread(&des, sizeof(des), 1, fh);
			header.crc32 = des.crc32;
			header.compressedsize = des.compressedsize;
			header.uncompressedsize = des.uncompressedsize;
		}
#endif

        // Note (flueke): For the broken listfile I got compression=8, crc=0,
        // and sizes both set to 4GB which was not the correct size. In the end
        // it didn't matter as the deflate code stopped producing data once the
        // input was fully decompressed (I noticed the output file size not
        // growing anymore after a certain max size was reached. At that point
        // I just killed the process.

        //printf("Got header compression=%u, crc=0x%08x, csize=%u, usize=%u\n",
        //        header.compression, header.crc32, header.compressedsize, header.uncompressedsize);
        printf("Got header compression=%u, crc=0x%08x\n",
                header.compression, header.crc32);
        printf("startloc=%llu\n", startloc);

        if (header.compression != 8)
        {
            printf("Error: expected header.compression=8 but got %u\n", header.compression);
            return 1;
        }

		fseek(fh, startloc, SEEK_SET);

		if (!header.compressedsize) {
			printf("Making directory %s\n", filename);
			for (i = 0; i < strlen(filename); ++i) {
				if (filename[i] == '/') {
					filename[i] = 0;
					mkdir(filename, S_IRWXU);
					filename[i] = '/';
				}
			}
		} else {
			//printf("Writing %s of length %f MB\n", filename, (float)header.compressedsize / (1024.0f * 1024.0f));
			printf("Writing %s\n", filename);
			ofh = fopen(filename, "wb");

			if (header.compression == 8) {
				strm.zalloc = Z_NULL;
				strm.zfree = Z_NULL;
				strm.opaque = Z_NULL;
				strm.avail_in = 0;
				strm.next_in = Z_NULL;
				inflateInit2(&strm, -MAX_WBITS);
				printf("Deflating.\n");
			}

            of_size = 0;
			while ((i = ftell(fh)) < (startloc + header.compressedsize))
            {
                // Note (flueke): Break out of the loop on eof as
                // header.compressedsize is not accurate at all (set to
                // 0xff..ff)
                if (feof(fh))
                    break;

				len = startloc + header.compressedsize - i;
				if (len > sizeof(buffer))
					len = sizeof(buffer);
				len = fread(buffer, 1, len, fh);
				if (header.compression == 8) {
					strm.avail_in = len;
					strm.next_in = buffer;
					do {
						strm.avail_out = sizeof(zbuffer);
						strm.next_out = zbuffer;
						if ((ret = inflate(&strm, Z_SYNC_FLUSH)) != Z_OK && ret != Z_STREAM_END && ret != Z_BUF_ERROR) {
							printf("Inflation failed, error %i.\n", ret);
							fseek(fh, startloc + header.compressedsize, SEEK_SET);
							break;
						}
						len = sizeof(zbuffer) - strm.avail_out;
						of_size += fwrite(zbuffer, 1, len, ofh);
					} while (strm.avail_out == 0);
				} else {
					of_size += fwrite(buffer, 1, len, ofh);
                }
			}
			if (header.compression == 8)
				inflateEnd(&strm);

			fclose(ofh);
            printf("Wrote %s, size=%lf MB\n", filename, of_size / (1024.0 * 1024.0));
		}
        // Note (flueke): hack to break out of outer loop after one file has
        // been deflated
        if (feof(fh))
            break;

		if (header.gen & (1 << 3))
			fseek(fh, sizeof(des) + sizeof(uint32_t), SEEK_CUR);
		first = 0;
	}
	fclose(fh);
	return 0;
}
